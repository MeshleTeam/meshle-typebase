<!DOCTYPE html>

<html>
<head>
  <title>Typebase</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="public/stylesheets/normalize.css" />
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div class="container">
    <div class="page">

      <div class="header">
        
          
          <h1 id="typebase">Typebase</h1>
<p><a href="https://github.com/jfamousket/meshle-typebase">typebase</a> provides C-like Types, Structs and Pointers for JavaScript.</p>
<p>Let’s jump straight into example. Consider the following <code>C/C++</code> <em>stuct</em>:</p>
<pre><code class="language-c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address</span> {</span>
    <span class="hljs-keyword">int</span> port,
    <span class="hljs-keyword">int</span> host,
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> ip[<span class="hljs-number">4</span>],
    <span class="hljs-keyword">int</span> status,
}</code></pre>
<p>You can represent it using <code>typebase</code> like so:</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> t = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;typebase&#x27;</span>);
<span class="hljs-keyword">var</span> Status = t.Bytes.define(
  [
    [<span class="hljs-string">&quot;powerOn&quot;</span>, t.b1],
    [<span class="hljs-string">&quot;timerEnabled&quot;</span>, t.b1],
    [<span class="hljs-string">&quot;errorFlag&quot;</span>, t.b1],
    [<span class="hljs-string">&quot;presenceSensor&quot;</span>, t.b1],
    [<span class="hljs-string">&quot;geoData&quot;</span>, t.b1],
    [<span class="hljs-string">&quot;deviceTime&quot;</span>, t.b1],
    [<span class="hljs-string">&quot;playerState&quot;</span>, t.b7],
  ],
  t.ui16,
  <span class="hljs-string">&quot;status&quot;</span>
);
<span class="hljs-keyword">var</span> address = t.Struct.define([
    [<span class="hljs-string">&#x27;port&#x27;</span>, t.i32],
    [<span class="hljs-string">&quot;host&quot;</span>, t.ui8],
    [<span class="hljs-string">&#x27;ip&#x27;</span>, t.List.define(t.ui8, <span class="hljs-number">4</span>)],
    [<span class="hljs-string">&quot;status&quot;</span>, Status],
]);</code></pre>
<p>You can use your <code>address</code> <em>struct</em> to pack binary data into <code>Buffer</code>. But, first
we create a <em>pointer</em> to memory where data will be located. <code>Pointer</code> is defined as
a tuple of <code>Buffer</code> and a <code>number</code> offset in the buffer:</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> t.Pointer(<span class="hljs-keyword">new</span> Buffer(address.size), <span class="hljs-number">0</span>);</code></pre>
<p>Finally, you can pack your data into the <code>Buffer</code> specified by the pointer <code>p</code>:</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> status = {
  <span class="hljs-attr">powerOn</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">timerEnabled</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">errorFlag</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">presenceSensor</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">geoData</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">deviceTime</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">playerState</span>: <span class="hljs-number">100</span>,
};
<span class="hljs-keyword">var</span> host = {
    <span class="hljs-attr">port</span>: <span class="hljs-number">8080</span>,
    <span class="hljs-attr">host</span>: <span class="hljs-number">128</span>,
    <span class="hljs-attr">ip</span>: [<span class="hljs-number">127</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],
    status
};
address.pack(p, host);</code></pre>
<p>And unpack it back:</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> unpacked = address.unpack(p);</code></pre>
<p>Or use <code>Variable</code> object to do the same thing:</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> t.Variable(address, p);
v.pack(host);
<span class="hljs-keyword">var</span> unpacked = v.unpack();</code></pre>
<p>Now let’s say you want to <em>“extend”</em> your C struct with a <code>protocol</code> field:</p>
<pre><code class="language-c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address_and_protocol</span> {</span>
    <span class="hljs-keyword">int</span> port,
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> ip[<span class="hljs-number">4</span>],
    <span class="hljs-keyword">int</span> protocol,
}</code></pre>
<p>In <em>C11</em> you can actually do it like this:</p>
<pre><code class="language-c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address_and_protocol</span> {</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address</span>,
    <span class="hljs-title">int</span> <span class="hljs-title">protocol</span>,
}</span></code></pre>
<p><code>typebase</code> also allows you to “extend” <code>Struct</code>s:</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> address_and_protocol = t.Struct.define([
    address,
    [<span class="hljs-string">&#x27;protocol&#x27;</span>, t.i32]
]);</code></pre>
<p>Now you can <em>“cast”</em> your <code>Variable</code> to the new type and write data to it:</p>
<pre><code class="language-js">v.cast(address_and_protocol);
v.pack({
    <span class="hljs-attr">port</span>: <span class="hljs-number">8080</span>,
    <span class="hljs-attr">host</span>: <span class="hljs-number">128</span>,
    <span class="hljs-attr">ip</span>: [<span class="hljs-number">127</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],
    status,
    <span class="hljs-attr">protocol</span>: <span class="hljs-number">4</span>
});</code></pre>
<p>When you pack and unpack <code>Variable</code>s, you don’t need to do it for the whole <code>Variable</code> at once, instead
you can just pick the field you need:</p>
<pre><code class="language-js">v.get(<span class="hljs-string">&#x27;ip&#x27;</span>).pack([<span class="hljs-number">192</span>, <span class="hljs-number">168</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100</span>]);
<span class="hljs-built_in">console</span>.log(v.get(<span class="hljs-string">&#x27;ip&#x27;</span>).unpack());</code></pre>
<p>One useful property all <code>typebase</code> types have is <code>size</code>, which is size of the type in bytes:</p>
<pre><code class="language-js"><span class="hljs-built_in">console</span>.log(address.size);</code></pre>
<h2 id="tldr">TL;DR</h2>
<p><code>typbase</code> defines five basic building blocks: <code>Pointer</code>, <code>Primitive</code>, <code>List</code>, <code>Struct</code>, <code>Variable</code>.</p>
<p><code>Pointer</code> represents a location of data in memory, similar to <code>C/C++</code> pointers.</p>
<p><code>Primitive</code> is a basic data type that knows how to pack and unpack itself into <code>Buffer</code>. <code>Struct</code> is a structure
of data, similar to <code>struct</code> in C. <code>List</code> is an array of <code>Primitive</code>s, <code>Struct</code>s or other <code>List</code>s.</p>
<p>And, finally, <code>Variable</code> is an object that has an <strong>address in memory</strong> represented by <code>Pointer</code> and a
<strong>type</strong> represented by one of <code>Primitive</code>, <code>List</code> or <code>Struct</code>.</p>

          
        

        
      </div>

      
        
        <p>This line is needed to use buffer for example in a react native app
comment out this line if not needed</p>

        
          <div class='highlight'><pre><span class="hljs-keyword">import</span> { Buffer } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;buffer/&quot;</span>;</pre></div>
        
      
        
        <h2 id="pointer">Pointer</h2>
<p>We can find out a physical memory pointer of a <code>Buffer</code> or <code>ArrayBuffer</code> objects using <a href="http://www.npmjs.com/package/libsys">libsys</a>.
But we don’t want to create a new buffer for every slice of memory we reference to, so we define a pointer as a tuple
where <code>Buffer</code> or <code>ArrayBuffer</code> objects server as a starting point and offset is a number representing an offset
within the buffer in bytes.</p>

        
          <div class='highlight'><pre><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pointer</span> </span>{
  <span class="hljs-attr">buf</span>: Buffer;
  off: <span class="hljs-built_in">number</span>; <span class="hljs-comment">/* offset */</span>

  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">buf: Buffer, offset: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span></span>)</span> {
    <span class="hljs-built_in">this</span>.buf = buf;
    <span class="hljs-built_in">this</span>.off = offset;
  }

  <span class="hljs-comment">/* Return a copy of itself. */</span>
  <span class="hljs-function"><span class="hljs-title">clone</span>(<span class="hljs-params"></span>)</span> {</pre></div>
        
      
        
        <p>return new Pointer(this.buf, this.off);</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.offset();
  }

  <span class="hljs-function"><span class="hljs-title">offset</span>(<span class="hljs-params">off: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span></span>)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pointer(<span class="hljs-built_in">this</span>.buf, <span class="hljs-built_in">this</span>.off + off);
  }
}</pre></div>
        
      
        
        <h2 id="types">Types</h2>

        
      
        
        <p>Basic properties that all types should have.</p>

        
          <div class='highlight'><pre><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IType {
  <span class="hljs-attr">size</span>: <span class="hljs-built_in">number</span>;
  name: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// Optional.</span>
  pack(p: Pointer, <span class="hljs-attr">data</span>: <span class="hljs-built_in">any</span>);
  unpack(p: Pointer, length?: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">any</span>;
}</pre></div>
        
      
        
        <h3 id="primitive">Primitive</h3>

        
      
        
        <p><code>Primitive</code>s are the smallest, most basic data types like integers, chars and pointers on which CPU operates directly
and which know how to pack and unpack themselves into <code>Buffer</code>s.</p>

        
          <div class='highlight'><pre><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Primitive</span> <span class="hljs-title">implements</span> <span class="hljs-title">IType</span> </span>{
  <span class="hljs-comment">/* We do not define `offset` at construction because the
       offset property is set by a parent Struct. */</span>
  <span class="hljs-keyword">static</span> define(
    size = <span class="hljs-number">1</span>,
    onPack = (<span class="hljs-function">() =&gt;</span> {}) <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>,
    onUnpack = (<span class="hljs-function">() =&gt;</span> {}) <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;&quot;</span>
  ) {
    <span class="hljs-keyword">var</span> field = <span class="hljs-keyword">new</span> Primitive();
    field.size = size;
    field.name = name;
    field.onPack = onPack;
    field.onUnpack = onUnpack;
    <span class="hljs-keyword">return</span> field;
  }

  size = <span class="hljs-number">0</span>;
  name: <span class="hljs-built_in">string</span>;

  onPack: <span class="hljs-function">(<span class="hljs-params">value, offset</span>) =&gt;</span> <span class="hljs-built_in">void</span>;
  onUnpack: <span class="hljs-function">(<span class="hljs-params">offset: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">any</span>;

  <span class="hljs-function"><span class="hljs-title">pack</span>(<span class="hljs-params">p: Pointer, value: <span class="hljs-built_in">any</span></span>)</span> {
    <span class="hljs-built_in">this</span>.onPack.call(p.buf, value, p.off);
  }

  unpack(p: Pointer): <span class="hljs-built_in">any</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.onUnpack.call(p.buf, p.off);
  }
}</pre></div>
        
      
        
        <h3 id="string">String</h3>

        
      
        
        <p><code>String</code>s are used to pack strings into the buffer
encoding specifies how the encoding format used for the packing</p>

        
      
        
        <p>String encodings available</p>

        
          <div class='highlight'><pre>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> encoding =
  | <span class="hljs-string">&quot;utf8&quot;</span>
  | <span class="hljs-string">&quot;utf16le&quot;</span>
  | <span class="hljs-string">&quot;latin1&quot;</span>
  | <span class="hljs-string">&quot;base64&quot;</span>
  | <span class="hljs-string">&quot;hex&quot;</span>
  | <span class="hljs-string">&quot;ascii&quot;</span>
  | <span class="hljs-string">&quot;binary&quot;</span>
  | <span class="hljs-string">&quot;ucs2&quot;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span> <span class="hljs-title">implements</span> <span class="hljs-title">IType</span> </span>{
  <span class="hljs-comment">/* We do not define `offset` at construction because the
       offset property is set by a parent Struct. */</span>
  <span class="hljs-keyword">static</span> define(
    encoding: encoding,
    <span class="hljs-attr">type</span>: IType,
    onPack = (<span class="hljs-function">() =&gt;</span> {}) <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>,
    onUnpack = (<span class="hljs-function">() =&gt;</span> {}) <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;&quot;</span>
  ) {
    <span class="hljs-keyword">var</span> field = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>();
    field.encoding = encoding;
    field.size = <span class="hljs-keyword">type</span>.size;
    field.name = name;
    field.onPack = onPack;
    field.onUnpack = onUnpack;
    <span class="hljs-keyword">return</span> field;
  }

  size = <span class="hljs-number">0</span>;
  encoding: encoding = <span class="hljs-string">&quot;utf8&quot;</span>;
  name: <span class="hljs-built_in">string</span>;

  onPack: <span class="hljs-function">(<span class="hljs-params">value, offset</span>) =&gt;</span> <span class="hljs-built_in">void</span>;
  onUnpack: <span class="hljs-function">(<span class="hljs-params">offset: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">any</span>;

  <span class="hljs-function"><span class="hljs-title">pack</span>(<span class="hljs-params">p: Pointer, value: <span class="hljs-built_in">any</span></span>)</span> {
    <span class="hljs-built_in">this</span>.onPack.call(p.buf, value, p.off, <span class="hljs-built_in">this</span>.size, <span class="hljs-built_in">this</span>.encoding);
  }

  unpack(p: Pointer): <span class="hljs-built_in">any</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.onUnpack.call(p.buf, <span class="hljs-built_in">this</span>.encoding, p.off, p.off + <span class="hljs-built_in">this</span>.size);
  }
}</pre></div>
        
      
        
        <h3 id="bit">Bit</h3>

        
      
        
        <p>A <code>Bit</code> is the smallest, most basic data type it can only be used inside <code>Bytes</code></p>

        
          <div class='highlight'><pre><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bit</span> </span>{
  <span class="hljs-comment">/* We do not define `offset` at construction because the
       offset property is set by a parent Struct. */</span>
  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">define</span>(<span class="hljs-params">size = <span class="hljs-number">1</span></span>)</span> {
    <span class="hljs-keyword">var</span> bit = <span class="hljs-keyword">new</span> Bit();
    bit.size = size;
    <span class="hljs-keyword">return</span> bit;
  }
  size = <span class="hljs-number">0</span>;
}</pre></div>
        
      
        
        <h3 id="list">List</h3>

        
      
        
        <p>Array type, named <code>List</code> because <code>Array</code> is a reserved word in JavaScript.</p>

        
          <div class='highlight'><pre><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span> <span class="hljs-title">implements</span> <span class="hljs-title">IType</span> </span>{
  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">define</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>: IType, length: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span></span>)</span> {
    <span class="hljs-keyword">var</span> list = <span class="hljs-keyword">new</span> List();
    list.type = <span class="hljs-keyword">type</span>;
    list.length = length;
    list.size = length * <span class="hljs-keyword">type</span>.size;
    <span class="hljs-keyword">return</span> list;
  }

  size = <span class="hljs-number">0</span>;
  name: <span class="hljs-built_in">string</span>;

  <span class="hljs-keyword">type</span>: IType;

  <span class="hljs-comment">/* If 0, means we don&#x27;t know the exact size of our array,
       think char[]* for example to represent string. */</span>
  length = <span class="hljs-number">0</span>;

  <span class="hljs-function"><span class="hljs-title">pack</span>(<span class="hljs-params">p: Pointer, values: <span class="hljs-built_in">any</span>[], length = <span class="hljs-built_in">this</span>.length</span>)</span> {
    <span class="hljs-keyword">var</span> valp = p.clone();</pre></div>
        
      
        
        <p>This allows to provide simle <code>number</code>s where 64-bit <code>[number, number]</code> is required.</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">if</span> (!(values <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>)) values = [values];

    <span class="hljs-keyword">if</span> (!length) length = values.length;
    length = <span class="hljs-built_in">Math</span>.min(length, values.length);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
      <span class="hljs-built_in">this</span>.type.pack(valp, values[i]);
      valp.off += <span class="hljs-built_in">this</span>.type.size;
    }
  }

  unpack(p: Pointer, length = <span class="hljs-built_in">this</span>.length): <span class="hljs-built_in">any</span> {
    <span class="hljs-keyword">var</span> values = [];
    <span class="hljs-keyword">var</span> valp = p.clone();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
      values.push(<span class="hljs-built_in">this</span>.type.unpack(valp));
      valp.off += <span class="hljs-built_in">this</span>.type.size;
    }
    <span class="hljs-keyword">return</span> values;
  }
}</pre></div>
        
      
        
        <h3 id="struct">Struct</h3>

        
      
        
        <p>Each <code>IType</code> inside a <code>Struct</code> gets decorated with the <code>IStructField</code> object.</p>

        
          <div class='highlight'><pre><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IStructField</span> </span>{
  <span class="hljs-attr">type</span>: IType;
  offset: <span class="hljs-built_in">number</span>;
  name: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> IFieldDefinition = [<span class="hljs-built_in">string</span>, IType] | Struct;</pre></div>
        
      
        
        <p>Represents a structured memory record definition similar to that of <code>struct</code> in <code>C</code>.</p>

        
          <div class='highlight'><pre><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Struct</span> <span class="hljs-title">implements</span> <span class="hljs-title">IType</span> </span>{
  <span class="hljs-keyword">static</span> define(fields: IFieldDefinition[], <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;&quot;</span>): Struct {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Struct(fields, name);
  }

  <span class="hljs-attr">fieldsDefinition</span>: IFieldDefinition[];
  size = <span class="hljs-number">0</span>;
  name: <span class="hljs-built_in">string</span>;

  fields: IStructField[] = [];

  map: { [s: <span class="hljs-built_in">string</span>]: IStructField } = {};

  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">fields: IFieldDefinition[], name: <span class="hljs-built_in">string</span></span>)</span> {
    <span class="hljs-built_in">this</span>.addFields(fields);
    <span class="hljs-built_in">console</span>.log(name);

    <span class="hljs-built_in">this</span>.name = name;
    <span class="hljs-built_in">this</span>.fieldsDefinition = fields;
  }

  <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-title">addFields</span>(<span class="hljs-params">fields: IFieldDefinition[]</span>)</span> {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> field <span class="hljs-keyword">of</span> fields) {
      <span class="hljs-comment">/* Inherit properties from another struct */</span>
      <span class="hljs-keyword">if</span> (field <span class="hljs-keyword">instanceof</span> Struct) {
        <span class="hljs-keyword">var</span> parent = field <span class="hljs-keyword">as</span> Struct;
        <span class="hljs-keyword">var</span> parentfields = parent.fields.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">field: IStructField</span>) </span>{
          <span class="hljs-keyword">return</span> [field.type, field.name];
        });
        <span class="hljs-built_in">this</span>.addFields(parentfields <span class="hljs-keyword">as</span> [<span class="hljs-built_in">string</span>, IType][]);
        <span class="hljs-keyword">continue</span>;
      }

      <span class="hljs-keyword">var</span> fielddef = field <span class="hljs-keyword">as</span> [<span class="hljs-built_in">string</span>, IType];
      <span class="hljs-keyword">var</span> [name, struct] = fielddef;
      <span class="hljs-keyword">var</span> entry: IStructField = {
        <span class="hljs-attr">type</span>: struct,
        <span class="hljs-attr">offset</span>: <span class="hljs-built_in">this</span>.size,
        <span class="hljs-attr">name</span>: name,
      };
      <span class="hljs-built_in">this</span>.fields.push(entry);
      <span class="hljs-built_in">this</span>.map[name] = entry;
      <span class="hljs-built_in">this</span>.size += struct.size;
    }
  }

  <span class="hljs-function"><span class="hljs-title">pack</span>(<span class="hljs-params">p: Pointer, data: <span class="hljs-built_in">any</span></span>)</span> {
    <span class="hljs-keyword">var</span> fp = p.clone();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> field <span class="hljs-keyword">of</span> <span class="hljs-built_in">this</span>.fields) {
      field.type.pack(fp, data[field.name]);
      fp.off += field.type.size;
    }
  }

  unpack(p: Pointer): <span class="hljs-built_in">any</span> {
    <span class="hljs-keyword">var</span> data: <span class="hljs-built_in">any</span> = {};
    <span class="hljs-keyword">var</span> fp = p.clone();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> field <span class="hljs-keyword">of</span> <span class="hljs-built_in">this</span>.fields) {
      data[field.name] = field.type.unpack(fp);
      fp.off += field.type.size;
    }
    <span class="hljs-keyword">return</span> data;
  }
}</pre></div>
        
      
        
        <h3 id="byte">Byte</h3>

        
      
        
        <p>Each <code>Bit</code> inside a <code>Byte</code> gets decorated with the <code>IByteField</code> object.</p>

        
          <div class='highlight'><pre><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IByteField</span> </span>{
  <span class="hljs-attr">type</span>: Bit;
  offset: <span class="hljs-built_in">number</span>;
  name: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> IBitDefinition = [<span class="hljs-built_in">string</span>, Bit] | Byte;</pre></div>
        
      
        
        <p>Represents a byte or bytes in memory record
1 byte can be represented using <code>Byte</code>, this depends on the type passed to the define function</p>

        
          <div class='highlight'><pre><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Byte</span> <span class="hljs-title">implements</span> <span class="hljs-title">IType</span> </span>{
  <span class="hljs-keyword">static</span> define(bits: IBitDefinition[], <span class="hljs-attr">type</span>: IType, <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;&quot;</span>): Byte {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Byte(bits, <span class="hljs-keyword">type</span>, name);
  }

  size = <span class="hljs-number">0</span>;
  off = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">type</span>: IType;
  name: <span class="hljs-built_in">string</span>;

  bitsDefinition: IBitDefinition[];
  bits: IByteField[] = [];

  map: { [s: <span class="hljs-built_in">string</span>]: IByteField } = {};

  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">bits: IBitDefinition[], <span class="hljs-keyword">type</span>: IType, name: <span class="hljs-built_in">string</span></span>)</span> {
    <span class="hljs-built_in">this</span>.addBits(bits);
    <span class="hljs-built_in">this</span>.size = <span class="hljs-keyword">type</span>.size;
    <span class="hljs-built_in">this</span>.name = name;
    <span class="hljs-built_in">this</span>.type = <span class="hljs-keyword">type</span>;
    <span class="hljs-built_in">this</span>.bitsDefinition = bits;
  }

  <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-title">addBits</span>(<span class="hljs-params">bits: IBitDefinition[]</span>)</span> {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> bit <span class="hljs-keyword">of</span> bits) {
      <span class="hljs-keyword">var</span> bitDef = bit <span class="hljs-keyword">as</span> [<span class="hljs-built_in">string</span>, Bit];
      <span class="hljs-keyword">var</span> [name, bitType] = bitDef;
      <span class="hljs-keyword">if</span> (!(bitType <span class="hljs-keyword">instanceof</span> Bit))
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Bytes can only contain bits&quot;</span>);
      <span class="hljs-keyword">var</span> entry: IByteField = {
        <span class="hljs-attr">type</span>: bitType,
        <span class="hljs-attr">offset</span>: <span class="hljs-built_in">this</span>.off,
        <span class="hljs-attr">name</span>: name,
      };
      <span class="hljs-built_in">this</span>.bits.push(entry);
      <span class="hljs-built_in">this</span>.map[name] = entry;
      <span class="hljs-built_in">this</span>.off += bitType.size;
    }
  }

  <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-title">padBit</span>(<span class="hljs-params">bit: <span class="hljs-built_in">string</span>, size: <span class="hljs-built_in">number</span></span>)</span> {
    bit = bit.toString();
    <span class="hljs-keyword">while</span> (bit.length &lt; size) bit = <span class="hljs-string">&quot;0&quot;</span> + bit;
    <span class="hljs-keyword">return</span> bit;
  }

  <span class="hljs-function"><span class="hljs-title">pack</span>(<span class="hljs-params">p: Pointer, data: <span class="hljs-built_in">any</span></span>)</span> {
    <span class="hljs-keyword">var</span> fp = p.clone();
    <span class="hljs-keyword">var</span> binaryNum =
      <span class="hljs-string">&quot;0b&quot;</span> +
      <span class="hljs-built_in">this</span>.bits
        .map(<span class="hljs-function">(<span class="hljs-params">b</span>) =&gt;</span> {
          <span class="hljs-keyword">let</span> d = data[b.name];
          d = <span class="hljs-built_in">Number</span>(d).toString(<span class="hljs-number">2</span>);
          d = <span class="hljs-built_in">this</span>.padBit(d, b.type.size);
          <span class="hljs-keyword">return</span> d.toString(<span class="hljs-number">2</span>);
        })
        .join(<span class="hljs-string">&quot;&quot;</span>);
    <span class="hljs-built_in">this</span>.type.pack(fp, <span class="hljs-built_in">Number</span>(binaryNum));
    fp.off += <span class="hljs-built_in">this</span>.size;
  }

  unpack(p: Pointer): <span class="hljs-built_in">any</span> {
    <span class="hljs-keyword">let</span> data: <span class="hljs-built_in">any</span> = {};
    <span class="hljs-keyword">let</span> fp = p.clone();
    <span class="hljs-keyword">let</span> offset = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> binaryNum = <span class="hljs-built_in">this</span>.type.unpack(fp);
    <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">typeof</span> binaryNum === <span class="hljs-string">&quot;number&quot;</span>))
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;invalid pointer passed to unpack function&quot;</span>);
    binaryNum = <span class="hljs-built_in">this</span>.padBit(binaryNum.toString(<span class="hljs-number">2</span>), <span class="hljs-built_in">this</span>.type.size * <span class="hljs-number">8</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> bit <span class="hljs-keyword">of</span> <span class="hljs-built_in">this</span>.bits) {
      <span class="hljs-keyword">var</span> decimalNum = binaryNum.slice(offset, offset + bit.type.size);
      decimalNum = <span class="hljs-string">&quot;0b&quot;</span> + <span class="hljs-built_in">this</span>.padBit(decimalNum, bit.type.size);
      decimalNum = <span class="hljs-built_in">Number</span>(decimalNum);
      data[bit.name] = <span class="hljs-built_in">Number</span>(decimalNum.toString(<span class="hljs-number">10</span>));
      offset += bit.type.size;
    }
    fp.off += <span class="hljs-built_in">this</span>.type.size;
    <span class="hljs-keyword">return</span> data;
  }
}</pre></div>
        
      
        
        <p>Represents an array of bits in memory record
upto 8 bytes can be represented using <code>Byte</code>, this depends on the type passed to the define function</p>

        
      
        
        <p>@ts-ignore</p>

        
          <div class='highlight'><pre><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteArr</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Byte</span> </span>{
  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">define</span>(<span class="hljs-params">bits: <span class="hljs-built_in">number</span>, <span class="hljs-keyword">type</span>: IType, name: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;&quot;</span></span>)</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span>.size !== bits / <span class="hljs-number">8</span>)
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Too many bits for <span class="hljs-subst">${<span class="hljs-keyword">type</span>.size}</span> byte(s)`</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ByteArr(
      <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(bits).fill(<span class="hljs-number">0</span>).map(<span class="hljs-function">(<span class="hljs-params">v, i</span>) =&gt;</span> [<span class="hljs-string">`<span class="hljs-subst">${i}</span>`</span>, b1]),
      <span class="hljs-keyword">type</span>,
      name
    );
  }

  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">bits: IBitDefinition[], <span class="hljs-keyword">type</span>: IType, name: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;&quot;</span></span>)</span> {
    <span class="hljs-built_in">super</span>(bits, <span class="hljs-keyword">type</span>, name);
  }

  <span class="hljs-function"><span class="hljs-title">unpack</span>(<span class="hljs-params">p: Pointer</span>)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.values(<span class="hljs-built_in">super</span>.unpack(p)).reverse();
  }

  <span class="hljs-function"><span class="hljs-title">getArr</span>(<span class="hljs-params">data: <span class="hljs-built_in">number</span></span>)</span> {
    <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> Pointer(<span class="hljs-keyword">new</span> Buffer(<span class="hljs-built_in">this</span>.type.size), <span class="hljs-number">0</span>);
    <span class="hljs-keyword">const</span> v = <span class="hljs-keyword">new</span> Variable(<span class="hljs-built_in">this</span>.type, p);
    v.pack(data);
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.unpack(p);
  }

  <span class="hljs-function"><span class="hljs-title">pack</span>(<span class="hljs-params">p: Pointer, data: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">any</span>&gt; | <span class="hljs-built_in">number</span></span>)</span> {
    <span class="hljs-keyword">if</span> (!(data <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>)) data = <span class="hljs-built_in">this</span>.getArr(data);
    data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-built_in">this</span>.type.size * <span class="hljs-number">8</span>)
      .fill(<span class="hljs-number">0</span>)
      .map(<span class="hljs-function">(<span class="hljs-params">v, i</span>) =&gt;</span> data[i] || v)
      .reverse()
      .reduce(<span class="hljs-function">(<span class="hljs-params">a, c, i</span>) =&gt;</span> {
        a[<span class="hljs-string">`<span class="hljs-subst">${i}</span>`</span>] = c;
        <span class="hljs-keyword">return</span> a;
      }, {});
    <span class="hljs-built_in">super</span>.pack(p, data);
  }
}</pre></div>
        
      
        
        <h2 id="variable">Variable</h2>
<p>Represents a variable that has a <code>Struct</code> type association with a <code>Pointer</code> to a memory location.</p>

        
          <div class='highlight'><pre><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Variable</span> </span>{
  <span class="hljs-attr">type</span>: IType;
  pointer: Pointer;

  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>: IType, pointer: Pointer</span>)</span> {
    <span class="hljs-built_in">this</span>.type = <span class="hljs-keyword">type</span>;
    <span class="hljs-built_in">this</span>.pointer = pointer;
  }

  <span class="hljs-function"><span class="hljs-title">pack</span>(<span class="hljs-params">data: <span class="hljs-built_in">any</span></span>)</span> {
    <span class="hljs-built_in">this</span>.type.pack(<span class="hljs-built_in">this</span>.pointer, data);
  }

  unpack(length?): <span class="hljs-built_in">any</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.type.unpack(<span class="hljs-built_in">this</span>.pointer, length);
  }

  <span class="hljs-function"><span class="hljs-title">cast</span>(<span class="hljs-params">newtype: IType</span>)</span> {
    <span class="hljs-built_in">this</span>.type = newtype;
  }

  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>)</span> {
    <span class="hljs-keyword">if</span> (!(<span class="hljs-built_in">this</span>.type <span class="hljs-keyword">instanceof</span> Struct))
      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Variable is not a `Struct`.&quot;</span>);
    <span class="hljs-keyword">var</span> struct = <span class="hljs-built_in">this</span>.type <span class="hljs-keyword">as</span> Struct;
    <span class="hljs-keyword">var</span> field = struct.map[name] <span class="hljs-keyword">as</span> IStructField;
    <span class="hljs-keyword">var</span> p = <span class="hljs-built_in">this</span>.pointer.clone();
    p.off += field.offset;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Variable(field.type, p);
  }
}</pre></div>
        
      
        
        <h2 id="basic-types">Basic Types</h2>
<p>Define basic types and export as part of the library.</p>

        
          <div class='highlight'><pre><span class="hljs-keyword">var</span> bp = Buffer.prototype;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> b1 = Bit.define(<span class="hljs-number">1</span>);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> b2 = Bit.define(<span class="hljs-number">2</span>);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> b3 = Bit.define(<span class="hljs-number">3</span>);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> b4 = Bit.define(<span class="hljs-number">4</span>);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> b5 = Bit.define(<span class="hljs-number">5</span>);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> b6 = Bit.define(<span class="hljs-number">6</span>);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> b7 = Bit.define(<span class="hljs-number">7</span>);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> i8 = Primitive.define(<span class="hljs-number">1</span>, bp.writeInt8, bp.readInt8);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> ui8 = Primitive.define(<span class="hljs-number">1</span>, bp.writeUInt8, bp.readUInt8);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> i16 = Primitive.define(<span class="hljs-number">2</span>, bp.writeInt16LE, bp.readInt16LE);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> ui16 = Primitive.define(<span class="hljs-number">2</span>, bp.writeUInt16LE, bp.readUInt16LE);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> i32 = Primitive.define(<span class="hljs-number">4</span>, bp.writeInt32LE, bp.readInt32LE);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> ui32 = Primitive.define(<span class="hljs-number">4</span>, bp.writeUInt32LE, bp.readUInt32LE);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> i64 = List.define(i32, <span class="hljs-number">2</span>);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> ui64 = List.define(ui32, <span class="hljs-number">2</span>);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> bi16 = Primitive.define(<span class="hljs-number">2</span>, bp.writeInt16BE, bp.readInt16BE);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> bui16 = Primitive.define(<span class="hljs-number">2</span>, bp.writeUInt16BE, bp.readUInt16BE);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> bi32 = Primitive.define(<span class="hljs-number">4</span>, bp.writeInt32BE, bp.readInt32BE);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> bui32 = Primitive.define(<span class="hljs-number">4</span>, bp.writeUInt32BE, bp.readUInt32BE);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> bi64 = List.define(bi32, <span class="hljs-number">2</span>);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> bui64 = List.define(bui32, <span class="hljs-number">2</span>);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> sui16 = <span class="hljs-built_in">String</span>.define(<span class="hljs-string">&quot;utf8&quot;</span>, ui16, bp.write, bp.toString);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> sui32 = <span class="hljs-built_in">String</span>.define(<span class="hljs-string">&quot;utf8&quot;</span>, ui32, bp.write, bp.toString);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> sui8 = <span class="hljs-built_in">String</span>.define(<span class="hljs-string">&quot;utf8&quot;</span>, ui8, bp.write, bp.toString);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> t_void = Primitive.define(<span class="hljs-number">0</span>); <span class="hljs-comment">// `0` means variable length, like `void*`.</span></pre></div>
        
      
      <div class="fleur">h</div>
    </div>
  </div>
</body>
</html>
